from __future__ import print_function
import socket
import time

samples_list = []
recovered_list = []
messages_list = [] #list for recovered and cutted messages
previous_sample_value = 0
current_sample_count = 0
previous_message_string = ""  #to save previous value
result_string = "" #string for the result sequence
#dictionary now include only letters and space 
dictionary = { 
	'000000110011001100111000111000011000011000011110011100110011000111100001110001100111111' : 'Q',\
	'00000011001100110011100011100001100001100001111001110011100011100001111001100001100111111' : 'W',\
	'00000011001100110011100011100001100001100001111001110011000111100001111000011100111111' : 'E',\
	'000000110011001100111000111000011000011000011110011100111001111000011110011110000111111' : 'R',\
	'000000110011001100111000111000011000011000011110011100110011100111100001100011100111111' : 'T',\
	'00000011001100110011100011100001100001100001111001110011100001100001111000011001100111111' : 'Y',\
	'000000110011001100111000111000011000011000011110011100110001100111100001100110000111111' : 'U',\
	'00000011001100110011100011100001100001100001111001110011100110011110000111001100111111' : 'I',\
	'00000011001100110011100011100001100001100001111001110011001100111001111001100001100111111' : 'O',\
	'000000110011001100111000111000011000011000011110011100111000110001100001110001100111111' : 'P',\
	'00000011001100110011100011100001100001100001111001110011001110011001111000111000111111' : 'A',\
	'00000011001100110011100011100001100001100001111001110011100001100110000110011100111111' : 'S',\
	'000000110011001100111000111000011000011000011110011100110001100110011110000111100111111' : 'D',\
	'00000011001100110011100011100001100001100001111001110011100110011001111001111001100111111' : 'F',\
	'00000011001100110011100011100001100001100001111001110011001100110011100110011100111111' : 'G',\
	'00000011001100110011100011100001100001100001111001110011100011001100011000111000111111' : 'H',\
	'00000011001100110011100011100001100001100001111001110011000111001100011001111001100111111' : 'J',\
	'000000110011001100111000111000011000011000011110011100111001110011000110000111100111111' : 'K',\
	'00000011001100110011100011100001100001100001111001110011001110001100011000011000111111' : 'L',\
	'00000011001100110011100011100001100001100001111001110011001110011100011000111001100111111' : 'Z',\
	'000000110011001100111000111000011000011000011110011100111000011000111001100111100111111' : 'X',\
	'00000011001100110011100011100001100001100001111001110011000110011100011000011100111111' : 'C',\
	'000000110011001100111000111000011000011000011110011100111001100111000110011110000111111' : 'V',\
	'00000011001100110011100011100001100001100001111001110011001100111000011000011001100111111' : 'B',\
	'000000110011001100111000111000011000011000011110011100111000110001111001100011100111111' : 'N',\
	'00000011001100110011100011100001100001100001111001110011000111000111100111001100111111' : 'M',\
	'000000110011001100111000111000011000011000011110011100110001100110000110011001100111111' : ' ',\
	'0000001100110011001110001110000110000110000111100111001100110001111000110011001100111111' : 'Q_release',\
	'00000011001100110011100011100001100001100001111001110011100011100001110001100111100111111' : 'W_release',\
	'000000110011001100111000111000011000011000011110011100110001111000011100111001100111111' : 'E_release',\
	'00000011001100110011100011100001100001100001111001110011100111100001110001110001100111111' : 'R_release',\
	'00000011001100110011100011100001100001100001111001110011001110011110001110000111100111111' : 'T_release',\
	'0000001100110011001110001110000110000110000111100111001110000110000111001110001100111111' : 'Y_release',\
	'000000110011001100111000111000011000011000011110011100110001100111100011100111100111111' : 'U_release',\
	'00000011001100110011100011100001100001100001111001110011100110011110001100111001100111111' : 'I_release',\
	'00000011001100110011100011100001100001100001111001110011001100111001110001100111100111111' : 'O_release',\
	'0000001100110011001110001110000110000110000111100111001110001100011000110011001100111111' : 'P_release',\
	'000000110011001100111000111000011000011000011110011100110011100110011100110011100111111' : 'A_release',\
	'00000011001100110011100011100001100001100001111001110011100001100110001110011001100111111' : 'S_release',\
	'0000001100110011001110001110000110000110000111100111001100011001100111001110011100111111' : 'D_release',\
	'0000001100110011001110001110000110000110000111100111001110011001100111000111001100111111' : 'F_release',\
	'000000110011001100111000111000011000011000011110011100110011001100111000011001100111111' : 'G_release',\
	'00000011001100110011100011100001100001100001111001110011100011001100011100110001100111111' : 'H_release',\
	'00000011001100110011100011100001100001100001111001110011000111001100011110001100111111' : 'J_release',\
	'00000011001100110011100011100001100001100001111001110011100111001100011100011000111111' : 'K_release',\
	'000000110011001100111000111000011000011000011110011100110011100011000111000111100111111' : 'L_release',\
	'0000001100110011001110001110000110000110000111100111001100111001110001110011001100111111' : 'Z_release',\
	'00000011001100110011100011100001100001100001111001110011100001100011100001100111100111111' : 'X_release',\
	'00000011001100110011100011100001100001100001111001110011000110011100011100011001100111111' : 'C_release',\
	'000000110011001100111000111000011000011000011110011100111001100111000111100011100111111' : 'V_release',\
	'00000011001100110011100011100001100001100001111001110011001100111000011100011100111111' : 'B_release',\
	'000000110011001100111000111000011000011000011110011100111000110001111000011110000111111' : 'N_release',\
	'000000110011001100111000111000011000011000011110011100110001110001111000110001100111111' : 'M_release',\
	'00000011001100110011100011100001100001100001111001110011000110011000011110011100111111' : 'Space_release',\
}

def main():
	sock = socket.socket()
	sock.bind(('', 9090))
	sock.listen(1)
	conn, addr = sock.accept()
	while 1:                        #infinite cycle to get bytes
	    data = conn.recv(1024) 
	    if not data: break
	    rebuild(data)                  #analyse is working in test function
	conn.close()

def rebuild(data):
	global previous_sample_value
	global current_sample_count

	for sample in data:
		samples_list.append(ord(sample))  #samples_list - list of 1 and 0 from binary file

	for sample in samples_list:
		if sample == 0:
			if previous_sample_value != 0:  #it means that there was peak before and his length = current sample count
			    recover_miller(current_sample_count, 1)
			    current_sample_count = 0
			else:
				current_sample_count += 1
		elif sample == 1:
			if previous_sample_value != 1: #it means that there was bottom
			    recover_miller(current_sample_count, 0)
			    current_sample_count = 0
			else:
				current_sample_count += 1
		previous_sample_value = sample

	del samples_list[:]    #after working with sample list we are deleting it
				
def recover_miller(current_sample_count, side):    #list for recovered bit sequence x2 because if we have 1.5 peaks we cannot write it
    global previous_message_string
    global result_string
    if current_sample_count >= 6 and current_sample_count <=10:
		if side == 1:
			recovered_list.append("11")   #we append real bit * 2
		elif side == 0:
			recovered_list.append("00")

    elif current_sample_count > 10 and current_sample_count < 14:
		if side == 1:
			recovered_list.append("111")
		elif side == 0:
			recovered_list.append("000")

    elif current_sample_count >= 14 and current_sample_count < 20:
		if side == 1:
			recovered_list.append("1111")
		elif side == 0:
			recovered_list.append("0000")

    elif current_sample_count >= 20 and current_sample_count < 28:
		if side == 1:
			recovered_list.append("111111")
			if "000000" in recovered_list: ###if we see the end of the message we will cut this message add it to new list and clear recovered list
			    start_index =  recovered_list.index("000000")
			    stop_index = recovered_list.index("111111") + 1
			    message = recovered_list[start_index:stop_index]
			    message_string = ''.join(message) #as list can't be dictionary key we will create string from list
			    if message_string in dictionary.keys():
			    	if message_string != previous_message_string: #not to repeat values
			    	    if not "release" in dictionary.get(message_string): #ignore releases, print only presses
			    	        result_string += dictionary.get(message_string)
			    	        print (result_string)
			    	previous_message_string = message_string  #to save previous value
			    del recovered_list[:] 
		elif side == 0:
			recovered_list.append("000000")

    elif current_sample_count < 7:
		recovered_list.append("too short peak")
    elif current_sample_count >= 28:
		recovered_list.append("too long bottom")


if __name__ == '__main__':
    main()
    
